## Routing

`iron-router` is a package that creates paths, and can also take care of filters (assigning actions to paths) and even subscriptions (controlling what paths have access to what data).

**Terminology**

`routes` - a route is the set of instructions that tell the app where to go and what to do when it encounters a URL

`paths` - a path is a URL within your app. It can be static (/terms_of_service) or dynamic (/posts/xyz), and even include query parameters (/search?keyword=meteor)

`segments` - the different parts of a path, delimited by forward slashes (/)

`hooks` - actions that you'd like to perform before, after, or even during the routing process (e.g. checking if the user has the proper rights before displaying a page)

`filters` - hooks that you define globally for one or more routes

`route templates` - each route needs to point to a template (if you don't specify one, the router will look for a template with the same name as the route by default)

`layouts` - layouts contain all the HTML code that wraps the current template, and will remain the same even if the template changes

`controllers` - sometimes, you'll realize that a lot of your templates are reusing the same parameters - rather than duplicate your code, you can let all these routes inherit from a single routing controller which will contain all the routing logic

## Mapping urls to templates

Without `iron-router`, we need to use hard-coded template includes for specific pages:

```
{{>postsList}})
```

What `iron-router` does is create a relationship between the route and the associated template, so we can just use `{{> yield}}` and the correct `route-template` will be rendered (depending on the path).

**Remove `body` from `main.html`**

```
// client/main.html

<head>
  <title>Microscope</title>
</head>
```

**Create `layout.html`**

```
// client/views/application/layout.html

<template name="layout">
  <div class="container">
  <header class="navbar">
    <div class="navbar-inner">
      <a class="brand" href="/">Microscope</a>
    </div>
  </header>
  <div id="main" class="row-fluid">
    {{> yield}}
  </div>
  </div>
</template>
```

**Create `router.js`, set a default layout, and create a route that maps `/` to the `postsList` template**

```
// lib/router.js

Router.configure({
  layoutTemplate: 'layout'
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
```

Note: anything in `lib` loads before everything else, and is available to client and server

## Named routes

Our route is named `postsList` - by default, `iron-router` will look for a template and path with the same name as the route (e.g. will render the `postsList` template at the path `/postsList`). Usually you want a custom path though.

Named routes also have a `{{ pathFor }}` helper that makes links easier to build:

```
<header class="navbar">
  <div class="navbar-inner">
    <a class="brand" href="{{pathFor 'postsList'}}">Microscope</a>
  </div>
</header>
```

## Waiting on data

Sometimes there will be a blank screen b/c the template renders before the data has come down the wire. You can create a "loading" experience to get around that.

```
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() { return Meteor.subscribe('posts'); }
});
Router.map(function() {
  this.route('postsList', {path: '/'});
});
Router.onBeforeAction('loading');
```

The last bit is a built-in loading `hook` that will make sure the `posts` subscription is loaded before rendering the `layout` template

Note: we're defining the `waitOn` function globally at the router level, not for certain routes, so the loading template will only be loaded the first time a user hits the app. The next time, the collection is already loaded.

Note: the router is now handling our subscription, so it's not needed in `main.js` anymore.

Lastly we need a `loading` template, which will use a package called `spin`:

`mrt add spin`

```
// client/views/includes/loading.html

<template name="loading">
  {{>spinner}}
</template>
```

